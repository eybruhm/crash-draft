Great! AI can see:
‚Ä¢	‚úÖ Backend has axios NOT installed (Django doesn't need it)
‚Ä¢	‚úÖ Frontend has axios ready
‚Ä¢	‚úÖ Backend has CORS configured (but port 3000, needs update to 5173 for Vite)
‚Ä¢	‚úÖ Backend has all needed packages (Django, DRF, Supabase, WeasyPrint, etc.)
Now here's your Step 5: Integration & Cleanup Roadmap:
________________________________________
üìã STEP 5: INTEGRATION & CLEANUP ROADMAP
üéØ Goals
1.	Wire frontend to backend APIs (replace all mock data)
2.	Align naming conventions between frontend/backend
3.	Implement real authentication with JWT
4.	Clean up hardcoded values, placeholders, and unused code
5.	Make both projects deployment-ready and maintainable
6.	Ensure frontend can work with any backend, backend can work with any frontend
‚úÖ Your Observations Are Correct!
‚Ä¢	Backend is ~90% done ‚úÖ (just needs real auth + minor tweaks)
‚Ä¢	Most work is frontend ‚úÖ (wiring + cleanup + alignment)
‚Ä¢	We clean as we integrate ‚úÖ (not two separate phases)
________________________________________
üóìÔ∏è DAY-BY-DAY EXECUTION PLAN
DAY 1: Foundation Setup & Real Authentication
Goal: Set up communication infrastructure and implement proper auth flow
Step 1: Backend - CORS & Environment Setup
Sub-steps:
1.	Update settings.py CORS to allow Vite dev server (port 5173)
2.	Verify .env has all required keys (SECRET_KEY, SUPABASE_*, GOOGLE_MAPS_API_KEY, DB credentials)
3.	Test backend is running and accessible from frontend
Description: CORS blocks frontend calls if not configured. Vite runs on 5173, not 3000.
Step 2: Backend - Implement Real JWT Authentication
Sub-steps:
1.	Install djangorestframework-simplejwt
2.	Configure JWT in settings.py (token lifetime, auth classes)
3.	Replace hardcoded password check with proper check_password() in LoginAPIView
4.	Return JWT access/refresh tokens instead of dummy tokens
5.	Create a test police account with hashed password in DB (via Django shell or migration)
Description: Currently login uses testpass hardcode. We need real password hashing and JWT tokens.
Step 3: Frontend - Create API Service Layer
Sub-steps:
1.	Create src/services/api.js - Axios instance with base URL configuration
2.	Add interceptor to attach JWT token to all requests (from localStorage)
3.	Add interceptor to handle 401 (expired token) ‚Üí redirect to login
4.	Create src/services/authService.js - login, logout, token refresh functions
Description: Centralize all API calls in one place. Makes switching backends easy.
Step 4: Frontend - Wire Real Login
Sub-steps:
1.	Update AuthContext.jsx login function to call backend /api/auth/login/
2.	Store JWT token (not dummy) in localStorage
3.	Parse and store user data from response
4.	Update logout to clear token and call backend if needed
5.	Add token expiry check on app load
Description: Replace mock login with real API call. Auth is now functional end-to-end.
Step 5: Testing & Verification
Sub-steps:
1.	Test login with correct credentials ‚Üí dashboard loads
2.	Test login with wrong credentials ‚Üí error message
3.	Test logout ‚Üí redirects to login
4.	Test protected route access without login ‚Üí redirects to login
5.	Check browser DevTools Network tab: JWT token in Authorization header
Description: Ensure auth works before moving to data wiring.
________________________________________
DAY 2: Dashboard & Reports Integration
Goal: Wire active reports list, detail view, and status updates
Step 1: Frontend - Create Reports Service
Sub-steps:
1.	Create src/services/reportsService.js
2.	Add functions: getActiveReports(), getReportDetail(id), updateReportStatus(id, status, remarks)
3.	Use the centralized API instance from Day 1
Description: Separate concerns - services handle API, components handle UI.
Step 2: Backend - Field Alignment Check
Sub-steps:
1.	Compare backend response fields vs frontend expectations
2.	Note differences (e.g., backend: reporter.first_name, frontend expects: reporterName)
3.	Document what needs to change (prefer changing frontend to match backend)
Description: Backend field names are already well-structured. Frontend should adapt.
Step 3: Frontend - Update Dashboard to Use Real Data
Sub-steps:
1.	Replace mock data in Dashboard.jsx with reportsService.getActiveReports()
2.	Add loading state during fetch
3.	Add error handling (show message if API fails)
4.	Map backend response fields to match component props:
o	reporter.first_name + reporter.last_name ‚Üí reporterName
o	reporter.phone ‚Üí reporterPhone
o	location_city ‚Üí city
o	location_barangay ‚Üí barangay
o	etc.
5.	Remove TemporaryDatabase.activeReports usage
Description: Components now display real database data. Mapping logic keeps components flexible.
Step 4: Frontend - Wire Report Detail Modal
Sub-steps:
1.	When "View" clicked, call getReportDetail(id) if not all data is in list response
2.	Update ReportDetailsModal to accept backend response format
3.	Handle missing fields gracefully (e.g., distance, eta initially null)
Description: Detail view may need full reporter info (emergency contact) not in list.
Step 5: Frontend - Wire Status Update
Sub-steps:
1.	When status dropdown changes in modal, call updateReportStatus(id, newStatus, remarks)
2.	Update local state after successful API call
3.	Show success/error notification (optional: toast library or simple alert)
4.	Refresh report list or update single item in state
Description: Police can now actually update report status in the database.
Step 6: Backend Cleanup - Remove Dummy Logic
Sub-steps:
1.	Verify all reports endpoints work with real data
2.	Add missing validation (e.g., status must be valid enum)
3.	Add comments to complex logic (nearest office assignment, geocoding)
Description: Polish backend while frontend is being wired.
________________________________________
DAY 3: Live Map & Checkpoints Integration
Goal: Display real map data and enable checkpoint management
Step 1: Frontend - Create Map & Checkpoint Services
Sub-steps:
1.	Create src/services/mapService.js - getMapData() calls /api/admin/map/data/
2.	Create src/services/checkpointsService.js - CRUD functions for checkpoints
Description: Map data comes from one endpoint; checkpoints have their own CRUD.
Step 2: Frontend - Wire Live Map Data
Sub-steps:
1.	In Map.jsx, replace mock data with getMapData()
2.	Parse response: active_reports, police_offices, active_checkpoints
3.	Map to marker format expected by Google Maps component
4.	Handle field alignment (backend uses assigned_office.office_name, etc.)
5.	Set up polling (every 30 seconds) to refresh map data
Description: Map now shows real-time data. Polling keeps it fresh.
Step 3: Backend - Verify Checkpoint Location Field
Sub-steps:
1.	Confirm Checkpoint model has location field (address string)
2.	Verify serializer returns it
3.	If missing, add field and update serializer
Description: Supabase schema added location column; ensure backend matches.
Step 4: Frontend - Wire Checkpoint CRUD
Sub-steps:
1.	AddCheckpointModal: on submit, call createCheckpoint() API
2.	EditCheckpointModal: on save, call updateCheckpoint(id) API
3.	Delete button: call deleteCheckpoint(id) API
4.	After each action, refresh checkpoints list or update state
5.	Handle assignedOfficers format: frontend uses array, backend accepts comma-separated string
Description: Officers can now manage checkpoints directly in the database.
Step 5: Frontend - Active/Inactive Logic Alignment
Sub-steps:
1.	Verify backend /api/checkpoints/active/ logic matches frontend filter
2.	If frontend calculates differently, use backend logic as source of truth
3.	Update UI filter to match backend behavior
Description: Consistency - don't calculate active status in two different ways.
________________________________________
DAY 4: Chat System & Directions Integration
Goal: Enable real-time messaging and navigation features
Step 1: Frontend - Create Messages Service
Sub-steps:
1.	Create src/services/messagesService.js
2.	Add getMessages(reportId), sendMessage(reportId, content, senderId, senderType, receiverId)
Description: Messages are nested under reports in the API.
Step 2: Frontend - Wire Chat Modal
Sub-steps:
1.	In ReportChatModal, replace mock data with getMessages(reportId)
2.	On send, call sendMessage() API
3.	Add polling (every 5 seconds) to fetch new messages
4.	Handle sender/receiver IDs correctly (police office ID vs user ID)
5.	Map backend timestamps to frontend display format
Description: Chat now works with real database. Polling simulates real-time.
Step 3: Backend - Add Google Maps API Key to .env
Sub-steps:
1.	Verify GOOGLE_MAPS_API_KEY is in backend .env
2.	Test /api/reports/{id}/route/ endpoint returns valid URL + QR
Description: Directions endpoint needs the key to generate QR/URL.
Step 4: Frontend - Wire Directions Modal
Sub-steps:
1.	When "Directions" clicked, call /api/reports/{id}/route/ API
2.	Use response directions_url and qr_code_base64
3.	Keep frontend haversine calculation as fallback if API fails
4.	Display both backend QR and frontend-calculated distance/ETA
Description: Backend provides official route; frontend can still show estimate.
Step 5: Frontend - Update Distance/ETA Display
Sub-steps:
1.	If backend response includes distance/duration from Google Directions API, use those
2.	Update state so ReportDetailsModal shows accurate info
3.	Add comment explaining fallback logic
Description: Accurate routing data improves police response.
________________________________________
DAY 5: Analytics & Resolved Cases Integration
Goal: Wire statistics, charts, and PDF exports
Step 1: Frontend - Create Analytics Service
Sub-steps:
1.	Create src/services/analyticsService.js
2.	Add functions: getOverview(filters), getLocationHotspots(filters), getCategoryStats(filters), exportAnalyticsPDF(filters)
Description: Analytics has multiple endpoints; centralize them.
Step 2: Frontend - Wire Analytics Page
Sub-steps:
1.	In Analytics.jsx, replace mock data with service calls
2.	Pass filter params (days, scope, office_id, city, barangay, category) to APIs
3.	Map response data to chart component format
4.	Handle empty results gracefully (show "No data" message)
5.	Wire "Export" button to trigger exportAnalyticsPDF() ‚Üí download blob
Description: Charts now show real crime statistics.
Step 3: Frontend - Create Resolved Cases Service
Sub-steps:
1.	Create src/services/resolvedCasesService.js
2.	Add getResolvedCases(filters), exportResolvedCasesPDF(filters), exportSingleCasePDF(reportId)
Description: Resolved cases have their own filtering and export logic.
Step 4: Frontend - Wire Resolved Cases Page
Sub-steps:
1.	In ResolvedCases.jsx, replace mock data with getResolvedCases()
2.	Pass filter params to API
3.	Map response fields (resolution_time_str, etc.)
4.	Wire export buttons to download PDFs from backend
Description: Audit log now shows real closed cases.
Step 5: Backend - Test PDF Generation
Sub-steps:
1.	Manually trigger PDF export endpoints with test filters
2.	Verify WeasyPrint renders correctly (no missing Cairo errors)
3.	Check PDF content matches filters
4.	Add comments to PDF template logic if unclear
Description: Ensure PDFs work before frontend calls them.
________________________________________
DAY 6 (UPDATED): Media Uploads & Final Cleanup (Police Web)
Goal: Implement real evidence uploads (image/video) and polish the Police web.
Step 0 (NEW): Backend ‚Äì Implement real Supabase Storage upload for tbl_media
Sub-steps:
1.	Choose a Supabase Storage bucket (ex: crash-media).
2.	Implement upload code so POST /api/v1/media/:
‚Ä¢	accepts multipart/form-data (uploaded_file, report, file_type, sender_id)
‚Ä¢	uploads bytes to Supabase Storage
‚Ä¢	saves returned public/signed URL into tbl_media.file_url
3.	Validate:
‚Ä¢	file_type must be image or video
‚Ä¢	file size limit (to protect free hosting)
4.	Protect endpoint:
‚Ä¢	require JWT
‚Ä¢	(recommended) only allow police to upload for reports assigned to their office
5.	Testing:
‚Ä¢	Postman upload ‚Üí confirm file exists in Supabase Storage
‚Ä¢	confirm row exists in tbl_media with correct file_url
Step 1: Frontend ‚Äì Create Media service
Sub-steps:
1.	Create src/services/mediaService.js
2.	Add:
‚Ä¢	getReportMedia(reportId)
‚Ä¢	uploadMedia(reportId, file, fileType, senderId) (FormData)
Step 2: Frontend ‚Äì Display existing attachments in ReportDetailsModal
Sub-steps:
1.	When modal opens, call getReportMedia(report.id)
2.	Render:
‚Ä¢	image preview thumbnails
‚Ä¢	video links (open in new tab)
Step 3: Frontend ‚Äì Upload UI in ReportDetailsModal
Sub-steps:
1.	Add ‚ÄúUpload Evidence‚Äù button + file picker
2.	Validate file type (image/video only)
3.	Show progress/loading state
4.	After upload success, refresh attachment list
Step 4: Cleanup ‚Äì confirm no mock data remains
Sub-steps:
1.	Search TemporaryDatabase references (should be none)
2.	Remove any leftover mock arrays used by pages/components
Step 5: UX polish ‚Äì loading/error states
Sub-steps:
1.	Confirm each page has loading/error/empty state
2.	(Optional) add reusable Spinner and ErrorBanner
Step 6: Frontend env setup (prep for deploy later)
Sub-steps:
1.	Add .env.example
2.	Make API base URL use VITE_API_BASE_URL (not hardcoded localhost)
Step 7: Code cleanup
Sub-steps:
1.	Remove debug logs
2.	Add short comments to tricky parts
________________________________________
DAY 6.5 (NEW): Mobile/Citizen Backend Readiness (Supabase Auth + Django APIs)
Goal: Citizens authenticate with Supabase Auth (email verification), then use Django APIs for profile, reports, media, and chat.
Step 0: Create a mobile views layer folder (as you requested)
Sub-steps:
1.	Add new backend file: Backend/core/views/mobile.py
2.	Keep citizen/mobile endpoints there (so it‚Äôs organized and separate from police/admin views)
Step 1: Supabase Auth setup (citizen signup/login/verification)
Sub-steps:
1.	In Supabase dashboard:
‚Ä¢	Enable Email Auth
‚Ä¢	Enable Email confirmation (verification email link)
2.	Mobile app:
‚Ä¢	uses Supabase client to signUp(email, password)
‚Ä¢	user clicks verification link in email
‚Ä¢	uses Supabase signInWithPassword(...)
‚Ä¢	mobile app gets a Supabase JWT access token (session token)
Description: Supabase handles verification email; Django does not send OTP/emails.
Step 2: Django ‚Äì Verify Supabase token on mobile API requests
Sub-steps:
1.	Create a helper like validate_supabase_user(request) (reads Authorization: Bearer <supabase_token>)
2.	Verify the Supabase JWT and extract the citizen‚Äôs auth_user_id
3.	Use that identity to allow/deny access
Step 3: Citizen Profile endpoints (stores details in tbl_users)
Sub-steps:
1.	GET /api/v1/mobile/profile/ ‚Üí returns citizen profile from tbl_users
2.	POST /api/v1/mobile/profile/ensure/:
‚Ä¢	first time after signup/login, create the tbl_users row if missing
3.	PATCH /api/v1/mobile/profile/ ‚Üí update profile fields (name, phone, address, emergency contact)
4.	Change password
‚Ä¢	If using Supabase Auth: password change is done via Supabase (not Django)
‚Ä¢	Django should only update profile fields, not passwords
Important: Optional fields (like some details) may be NULL ‚Äî backend should allow nulls.
Step 4: Citizen reports (SOS + detailed report; description/media optional)
Sub-steps:
1.	POST /api/v1/mobile/reports/:
‚Ä¢	required: lat/lng, category (default Emergency for SOS), reporter identity from token
‚Ä¢	optional: description (can be null)
2.	Enforce ‚ÄúActive Case Mode‚Äù rule:
‚Ä¢	if citizen already has a report not Resolved/Canceled ‚Üí block creating a new one (return a friendly error)
Step 5: Citizen media upload (optional media)
Sub-steps:
1.	If user attaches image/video:
‚Ä¢	call Django POST /api/v1/media/ with multipart form data
‚Ä¢	Django uploads to Supabase Storage and creates tbl_media row
2.	If no media, report still submits fine
Step 6: Citizen chat (user ‚Üî police)
Sub-steps:
1.	Update backend to allow sender_type='user' in messages (currently it only allows police)
2.	Add mobile endpoints:
‚Ä¢	GET /api/v1/mobile/reports/{id}/messages/
‚Ä¢	POST /api/v1/mobile/reports/{id}/messages/
3.	Permission checks:
‚Ä¢	citizen can only read/send messages for their own report
Step 7: Citizen cancel report
Sub-steps:
1.	POST /api/v1/mobile/reports/{id}/cancel/ (or PATCH status to Canceled)
2.	Only the report owner can cancel
________________________________________
DAY 7: Testing, Bug Fixing & Documentation
Goal: Ensure everything works end-to-end and document the system
Step 1: End-to-End Testing Scenarios
Sub-steps:
1.	Scenario 1: Login ‚Üí View dashboard ‚Üí Update report status ‚Üí Logout
2.	Scenario 2: Login ‚Üí Open map ‚Üí Add checkpoint ‚Üí Verify appears on map
3.	Scenario 3: Login ‚Üí Open chat ‚Üí Send message ‚Üí Verify in DB
4.	Scenario 4: Login ‚Üí Analytics ‚Üí Apply filters ‚Üí Export PDF ‚Üí Verify download
5.	Scenario 5: Login ‚Üí Resolved cases ‚Üí View details ‚Üí Export case PDF
Description: Test all major user flows work correctly.
Step 2: Edge Case Testing
Sub-steps:
1.	Test with no data (empty database) - does UI show "No results"?
2.	Test with invalid token (expired) - does app redirect to login?
3.	Test API failures (stop backend) - does UI show error message?
4.	Test long strings (names, descriptions) - does UI break?
5.	Test file upload with large file - does it handle gracefully?
Description: Robust apps handle edge cases without crashing.
Step 3: Bug Tracking & Fixes
Sub-steps:
1.	Create a simple bug list (text file or issue tracker)
2.	Prioritize: Critical (blocks features) ‚Üí Minor (cosmetic)
3.	Fix critical bugs first
4.	Test fix ‚Üí mark as resolved
Description: Systematic bug fixing prevents missing issues.
Step 4: Performance Optimization
Sub-steps:
1.	Check dashboard load time - should be < 2 seconds
2.	Optimize polling intervals (don't spam backend)
3.	Add pagination if report lists are huge (optional)
4.	Lazy load map markers if 100+ pins (optional)
Description: Fast app = better user experience.
Step 5: Documentation - Update README Files
Sub-steps:
1.	Backend README: Installation steps, env vars, run commands, API docs link
2.	Frontend README: Installation steps, env vars, run commands, project structure
3.	Overall README (root): Project overview, architecture diagram (simple text or image)
Description: Future you (or teammates) will thank you.
Step 6: Deployment Preparation Checklist
Sub-steps:
1.	Backend: Dockerfile ready, dependencies listed, env template
2.	Frontend: Build command works (npm run build), env vars documented
3.	Test production build locally before deploying
4.	Document deployment steps (Render/Fly backend, Netlify frontend)
Description: Deployment shouldn't be a mystery.
________________________________________
üìä SUCCESS CRITERIA (How to Know Each Day is Complete)
Day	Must Pass Before Moving On
1	Login with real credentials works; JWT token visible in browser storage; protected routes redirect without token
2	Dashboard shows real reports from DB; status updates save to DB; no mock data used
3	Map shows real pins from DB; add/edit/delete checkpoint works; changes visible immediately
4	Chat loads real messages; send message appears in DB; directions show real route from backend
5	Analytics charts use real data; filters work; PDF exports download successfully
6	File upload works; all mock data deleted; loading/error states everywhere
7	All test scenarios pass; critical bugs fixed; README files complete

‚úÖ Project Success Criteria (How to Know Each Day is Complete)
This list outlines the minimum functionality that must be achieved each day before moving on to the next.
‚Ä¢	Day 1: Login with real credentials works; JWT token visible in browser storage; protected routes redirect without token.
‚Ä¢	Day 2: Dashboard shows real reports from DB; status updates save to DB; no mock data used.
‚Ä¢	Day 3: Map shows real pins from DB; add/edit/delete checkpoint works; changes visible immediately.
‚Ä¢	Day 4: Chat loads real messages; send message appears in DB; directions show real route from backend.
‚Ä¢	Day 5: Analytics charts use real data; filters work; PDF exports download successfully.
‚Ä¢	Day 6: File upload works; all mock data deleted; loading/error states everywhere.
‚Ä¢	Day 7: All test scenarios pass; critical bugs fixed; README files complete.

________________________________________
üéì LEARNING NOTES (For Your Growth)
Key Concepts You'll Master:
1.	Separation of Concerns: API logic (services) vs UI logic (components)
2.	Authentication Flow: JWT tokens, protected routes, token refresh
3.	State Management: When to use Context vs local state
4.	API Design: RESTful endpoints, proper HTTP methods, error responses
5.	Deployment: Environment variables, CORS, production vs development
Best Practices You'll Learn:
1.	Never hardcode secrets (API keys, passwords) - always use .env
2.	Always handle loading/error states - apps fail gracefully
3.	Comments explain WHY, not WHAT - code shows what, comments show reasoning
4.	Test before deploying - catch bugs locally, not in production
5.	Document as you build - easier than documenting later
________________________________________
‚úÖ YOUR POINTS ADDRESSED
‚úÖ Frontend/Backend Alignment: Days 2-6 explicitly map fields and align naming
‚úÖ Independence: Service layer (Day 1) makes swapping backends easy
‚úÖ Comments: Day 6 Step 7 adds comprehensive comments
‚úÖ Backend 90% Done: Confirmed - mostly frontend work (you're right!)
‚úÖ Cleanup While Integrating: Every day includes cleanup sub-steps
‚úÖ Learning Mindset: Learning notes section + explanations in each step

Documentation Every after day we finish::
Day - Title/Goal
What was Done (each step and sub-step)
Files created and modified (this just my addition)
How to test (to find bugs and we will solve it. we dont move to next day until we are clear)
Current state
Important Notes
Next Steps/Day Preview (connecting to what we did)
Summary
[Just send it here in Chat Convo so even you can backread it!]


