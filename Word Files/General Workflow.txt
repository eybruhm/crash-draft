General Workflow
Goals: 
-	Integrate Frontend and Backend
-	Deploy a working and usable 

‚úÖ 1. Deep understanding and collection of context
     - Backend models, endpoints, logic
     - Frontend components, pages, structure
     - Database schema, Supabase setup

‚úÖ 2. Align Frontend Stack 
     - Create new React-Vite project
     - Set up folder structure
     - Configure Tailwind CSS
     - Test basic setup (runs without errors)

‚úÖ 3. Document Backend API Endpoints
     - Created API_ENDPOINTS_REFERENCE.md
     - Tested login and Supabase connection

‚úÖ 4. Port Frontend Components to Vite 
     - Copy components from Next.js ‚Üí Vite
     - Replace Next.js routing with react-router-dom
     - Keep all UI logic intact
     - Test each page renders correctly

‚úÖ 5. Planning Stage (Create Integration Roadmap For Police) 
     - Map each frontend feature to backend endpoint
     - Identify missing backend logic (nearest office, etc.)
     - Create day-by-day execution plan
     - Define success criteria for each day

‚úÖ 6. Execute Created Roadmap from Planning Stage Day-by-Day For Police
     - Day 1: Authentication flow (‚úÖ)
     - Day 2: Dashboard + Active Reports (‚úÖ)
     - Day 3: Map + Checkpoints (‚úÖ)
     - Day 4: Chat + Messages (‚úÖ)
     - Day 5: Analytics & Resolved Cases (‚úÖ)
     - Day 6: Media Uploads & Final Cleanup (‚úÖ)
     - Day 6.5: Mobile/Citizen Backend Readiness (THIS IS CANCELLED AND OPTIONAL NOW)

‚è≥ 7. Planning Stage (Create Integration Roadmap For Admin) 
     - [To be made]
	
‚è≥ 8. Execute Created Roadmap from Planning Stage Day-by-Day For Admin
     - [To be made]

‚è≥ 9. Overall Testing
     - End-to-end user flows
     - Edge cases and error handling
     - Performance testing (polling interval)
     - Mobile app integration testing

‚è≥ 10. Deployment Preparation
     - Environment variables setup
     - CORS configuration
     - Database migrations on production
     - Static file hosting

‚è≥ 11. Deploy
     - Backend: Render.com
     - Frontend: Netlify/Vercel
     - Test production environment

‚è≥ 12. Final Documentation
     - Setup guide for development
     - Deployment guide
     - API documentation
     - User manual (optional)





General Workflow (hierarchical)
Step 1: Deep Understanding (‚úÖ)
	Day 1: Backend models/endpoints, frontend structure, DB/Supabase review
Step 2: Align Frontend Stack (‚úÖ)
	Day 1: Create Vite app, Tailwind setup, router skeleton, smoke tests
Step 3: Document Backend API (‚úÖ)
	Day 1: API_ENDPOINTS_REFERENCE.md, auth/Supabase sanity checks
Step 4: Port Next.js Frontend to Vite (‚è≥ not sure if were done already)
	Day 1: Port globals (fonts/Tailwind base), layout shell, routing parity check (‚úÖ)
	Day 2: AuthContext + login page (UI parity, stubbed calls) (‚úÖ)
	Day 3: Dashboard + Active Reports UI (mock data first) (‚úÖ)
	Day 4: Map + Checkpoints UI (mock data, Google Maps wiring) (‚úÖ)
	Day 5: Chat + Messages UI (mock data) (‚úÖ)
	Day 6: Analytics UI (‚úÖ)
	Day 7: Resolved Cases + PDFs UI hooks (mock data), cross-page smoke tests (‚úÖ)
Step 5: Integration Planning (‚úÖ)
Step 6+: Full Integration Execution (we are here)



Roadmap for Step 4: Port Next ‚Üí Vite (‚úÖ)
Day 1: Port globals/layout (‚úÖ)
	Step 1: Copy Tailwind globals.css + font imports ‚Üí Vite
		Sub-step: Add Inter import to index.html or CSS
		Sub-step: Migrate utility classes/global resets
		Step 2: Layout shell + shared wrappers
		Sub-step: Bring over layout/container components if any
		Sub-step: Verify routing parity across pages
Day 2: AuthContext + Login (‚úÖ)
	Step 1: Port AuthContext (mock/stubbed)
		Sub-step: Replace Next router uses with react-router navigation
		Sub-step: Stub API calls until backend wiring
	Step 2: Port Login page
		Sub-step: Form, validation, success/failure states
Day 3: Dashboard + Active Reports (‚úÖ)
	Step 1: Port cards/tables/filters with mock data
		Sub-step: Ensure status badges use Tailwind theme
	Step 2: Wire navigation links/buttons between pages
Day 4: Map + Checkpoints (‚úÖ)
	Step 1: Port map component, markers, legend
		Sub-step: Swap Next-specific bits for react-router context
	Step 2: Port modals (add/edit checkpoint, directions, legend)
Day 5: Chat + Messages (‚úÖ)
	Step 1: Port chat UI components
	Step 2: Ensure message grouping/timestamps render with mock data
Day 6: Analytics (‚úÖ)
	Step 1: Port charts/widgets (mock data)
Day 7: Resolved Cases + PDFs (‚úÖ)
	Step 1: Port resolved cases list/detail modals
	Step 2: Wire PDF trigger stub
	Step 3: Cross-page smoke tests (all routes render)




Roadmap for Step 5: Integration Planning (‚è≥)
üóìÔ∏è DAY-BY-DAY EXECUTION PLAN 
DAY 1: Foundation Setup & Real Authentication (‚úÖ)
Goal: Set up communication infrastructure and implement proper auth flow
Step 1: Backend - CORS & Environment Setup
Sub-steps:
1.	Update settings.py CORS to allow Vite dev server (port 5173)
2.	Verify .env has all required keys (SECRET_KEY, SUPABASE_*, GOOGLE_MAPS_API_KEY, DB credentials)
3.	Test backend is running and accessible from frontend
Description: CORS blocks frontend calls if not configured. Vite runs on 5173, not 3000.
Step 2: Backend - Implement Real JWT Authentication
Sub-steps:
1.	Install djangorestframework-simplejwt
2.	Configure JWT in settings.py (token lifetime, auth classes)
3.	Replace hardcoded password check with proper check_password() in LoginAPIView
4.	Return JWT access/refresh tokens instead of dummy tokens
5.	Create a test police account with hashed password in DB (via Django shell or migration)
Description: Currently login uses testpass hardcode. We need real password hashing and JWT tokens.
Step 3: Frontend - Create API Service Layer
Sub-steps:
1.	Create src/services/api.js - Axios instance with base URL configuration
2.	Add interceptor to attach JWT token to all requests (from localStorage)
3.	Add interceptor to handle 401 (expired token) ‚Üí redirect to login
4.	Create src/services/authService.js - login, logout, token refresh functions
Description: Centralize all API calls in one place. Makes switching backends easy.
Step 4: Frontend - Wire Real Login
Sub-steps:
1.	Update AuthContext.jsx login function to call backend /api/auth/login/
2.	Store JWT token (not dummy) in localStorage
3.	Parse and store user data from response
4.	Update logout to clear token and call backend if needed
5.	Add token expiry check on app load
Description: Replace mock login with real API call. Auth is now functional end-to-end.
Step 5: Testing & Verification
Sub-steps:
1.	Test login with correct credentials ‚Üí dashboard loads
2.	Test login with wrong credentials ‚Üí error message
3.	Test logout ‚Üí redirects to login
4.	Test protected route access without login ‚Üí redirects to login
5.	Check browser DevTools Network tab: JWT token in Authorization header
Description: Ensure auth works before moving to data wiring.
________________________________________
DAY 2: Dashboard & Reports Integration (‚úÖ)
Goal: Wire active reports list, detail view, and status updates
Step 1: Frontend - Create Reports Service
Sub-steps:
1.	Create src/services/reportsService.js
2.	Add functions: getActiveReports(), getReportDetail(id), updateReportStatus(id, status, remarks)
3.	Use the centralized API instance from Day 1
Description: Separate concerns - services handle API, components handle UI.
Step 2: Backend - Field Alignment Check
Sub-steps:
1.	Compare backend response fields vs frontend expectations
2.	Note differences (e.g., backend: reporter.first_name, frontend expects: reporterName)
3.	Document what needs to change (prefer changing frontend to match backend)
Description: Backend field names are already well-structured. Frontend should adapt.
Step 3: Frontend - Update Dashboard to Use Real Data
Sub-steps:
1.	Replace mock data in Dashboard.jsx with reportsService.getActiveReports()
2.	Add loading state during fetch
3.	Add error handling (show message if API fails)
4.	Map backend response fields to match component props:
o	reporter.first_name + reporter.last_name ‚Üí reporterName
o	reporter.phone ‚Üí reporterPhone
o	location_city ‚Üí city
o	location_barangay ‚Üí barangay
o	etc.
5.	Remove TemporaryDatabase.activeReports usage
Description: Components now display real database data. Mapping logic keeps components flexible.
Step 4: Frontend - Wire Report Detail Modal
Sub-steps:
1.	When "View" clicked, call getReportDetail(id) if not all data is in list response
2.	Update ReportDetailsModal to accept backend response format
3.	Handle missing fields gracefully (e.g., distance, eta initially null)
Description: Detail view may need full reporter info (emergency contact) not in list.
Step 5: Frontend - Wire Status Update
Sub-steps:
1.	When status dropdown changes in modal, call updateReportStatus(id, newStatus, remarks)
2.	Update local state after successful API call
3.	Show success/error notification (optional: toast library or simple alert)
4.	Refresh report list or update single item in state
Description: Police can now actually update report status in the database.
Step 6: Backend Cleanup - Remove Dummy Logic
Sub-steps:
1.	Verify all reports endpoints work with real data
2.	Add missing validation (e.g., status must be valid enum)
3.	Add comments to complex logic (nearest office assignment, geocoding)
Description: Polish backend while frontend is being wired.
________________________________________
DAY 3: Live Map & Checkpoints Integration (‚úÖ)
Goal: Display real map data and enable checkpoint management
Step 1: Frontend - Create Map & Checkpoint Services
Sub-steps:
1.	Create src/services/mapService.js - getMapData() calls /api/admin/map/data/
2.	Create src/services/checkpointsService.js - CRUD functions for checkpoints
Description: Map data comes from one endpoint; checkpoints have their own CRUD.
Step 2: Frontend - Wire Live Map Data
Sub-steps:
1.	In Map.jsx, replace mock data with getMapData()
2.	Parse response: active_reports, police_offices, active_checkpoints
3.	Map to marker format expected by Google Maps component
4.	Handle field alignment (backend uses assigned_office.office_name, etc.)
5.	Set up polling (every 30 seconds) to refresh map data
Description: Map now shows real-time data. Polling keeps it fresh.
Step 3: Backend - Verify Checkpoint Location Field
Sub-steps:
1.	Confirm Checkpoint model has location field (address string)
2.	Verify serializer returns it
3.	If missing, add field and update serializer
Description: Supabase schema added location column; ensure backend matches.
Step 4: Frontend - Wire Checkpoint CRUD
Sub-steps:
1.	AddCheckpointModal: on submit, call createCheckpoint() API
2.	EditCheckpointModal: on save, call updateCheckpoint(id) API
3.	Delete button: call deleteCheckpoint(id) API
4.	After each action, refresh checkpoints list or update state
5.	Handle assignedOfficers format: frontend uses array, backend accepts comma-separated string
Description: Officers can now manage checkpoints directly in the database.
Step 5: Frontend - Active/Inactive Logic Alignment
Sub-steps:
1.	Verify backend /api/checkpoints/active/ logic matches frontend filter
2.	If frontend calculates differently, use backend logic as source of truth
3.	Update UI filter to match backend behavior
Description: Consistency - don't calculate active status in two different ways.
________________________________________
DAY 4: Chat System & Directions Integration (‚úÖ)
Goal: Enable real-time messaging and navigation features
Step 1: Frontend - Create Messages Service
Sub-steps:
1.	Create src/services/messagesService.js
2.	Add getMessages(reportId), sendMessage(reportId, content, senderId, senderType, receiverId)
Description: Messages are nested under reports in the API.
Step 2: Frontend - Wire Chat Modal
Sub-steps:
1.	In ReportChatModal, replace mock data with getMessages(reportId)
2.	On send, call sendMessage() API
3.	Add polling (every 5 seconds) to fetch new messages
4.	Handle sender/receiver IDs correctly (police office ID vs user ID)
5.	Map backend timestamps to frontend display format
Description: Chat now works with real database. Polling simulates real-time.
Step 3: Backend - Add Google Maps API Key to .env
Sub-steps:
1.	Verify GOOGLE_MAPS_API_KEY is in backend .env
2.	Test /api/reports/{id}/route/ endpoint returns valid URL + QR
Description: Directions endpoint needs the key to generate QR/URL.
Step 4: Frontend - Wire Directions Modal
Sub-steps:
1.	When "Directions" clicked, call /api/reports/{id}/route/ API
2.	Use response directions_url and qr_code_base64
3.	Keep frontend haversine calculation as fallback if API fails
4.	Display both backend QR and frontend-calculated distance/ETA
Description: Backend provides official route; frontend can still show estimate.
Step 5: Frontend - Update Distance/ETA Display
Sub-steps:
1.	If backend response includes distance/duration from Google Directions API, use those
2.	Update state so ReportDetailsModal shows accurate info
3.	Add comment explaining fallback logic
Description: Accurate routing data improves police response.
________________________________________
DAY 5: Analytics & Resolved Cases Integration (‚úÖ)
Goal: Wire statistics, charts, and PDF exports
Step 1: Frontend - Create Analytics Service
Sub-steps:
1.	Create src/services/analyticsService.js
2.	Add functions: getOverview(filters), getLocationHotspots(filters), getCategoryStats(filters), exportAnalyticsPDF(filters)
Description: Analytics has multiple endpoints; centralize them.
Step 2: Frontend - Wire Analytics Page
Sub-steps:
1.	In Analytics.jsx, replace mock data with service calls
2.	Pass filter params (days, scope, office_id, city, barangay, category) to APIs
3.	Map response data to chart component format
4.	Handle empty results gracefully (show "No data" message)
5.	Wire "Export" button to trigger exportAnalyticsPDF() ‚Üí download blob
Description: Charts now show real crime statistics.
Step 3: Frontend - Create Resolved Cases Service
Sub-steps:
1.	Create src/services/resolvedCasesService.js
2.	Add getResolvedCases(filters), exportResolvedCasesPDF(filters), exportSingleCasePDF(reportId)
Description: Resolved cases have their own filtering and export logic.
Step 4: Frontend - Wire Resolved Cases Page
Sub-steps:
1.	In ResolvedCases.jsx, replace mock data with getResolvedCases()
2.	Pass filter params to API
3.	Map response fields (resolution_time_str, etc.)
4.	Wire export buttons to download PDFs from backend
Description: Audit log now shows real closed cases.
Step 5: Backend - Test PDF Generation
Sub-steps:
1.	Manually trigger PDF export endpoints with test filters
2.	Verify WeasyPrint renders correctly (no missing Cairo errors)
3.	Check PDF content matches filters
4.	Add comments to PDF template logic if unclear
Description: Ensure PDFs work before frontend calls them.
________________________________________
DAY 6 (UPDATED): Media Uploads & Final Cleanup (Police Web) (‚úÖ)
Goal: Implement real evidence uploads (image/video) and polish the Police web.
Step 0 (NEW): Backend ‚Äì Implement real Supabase Storage upload for tbl_media
Sub-steps:
1.	Choose a Supabase Storage bucket (ex: crash-media).
2.	Implement upload code so POST /api/v1/media/:
‚Ä¢	accepts multipart/form-data (uploaded_file, report, file_type, sender_id)
‚Ä¢	uploads bytes to Supabase Storage
‚Ä¢	saves returned public/signed URL into tbl_media.file_url
3.	Validate:
‚Ä¢	file_type must be image or video
‚Ä¢	file size limit (to protect free hosting)
4.	Protect endpoint:
‚Ä¢	require JWT
‚Ä¢	(recommended) only allow police to upload for reports assigned to their office
5.	Testing:
‚Ä¢	Postman upload ‚Üí confirm file exists in Supabase Storage
‚Ä¢	confirm row exists in tbl_media with correct file_url
Step 1: Frontend ‚Äì Create Media service
Sub-steps:
1.	Create src/services/mediaService.js
2.	Add:
‚Ä¢	getReportMedia(reportId)
‚Ä¢	uploadMedia(reportId, file, fileType, senderId) (FormData)
Step 2: Frontend ‚Äì Display existing attachments in ReportDetailsModal
Sub-steps:
1.	When modal opens, call getReportMedia(report.id)
2.	Render:
‚Ä¢	image preview thumbnails
‚Ä¢	video links (open in new tab)
Step 3: Frontend ‚Äì Upload UI in ReportDetailsModal
Sub-steps:
1.	Add ‚ÄúUpload Evidence‚Äù button + file picker
2.	Validate file type (image/video only)
3.	Show progress/loading state
4.	After upload success, refresh attachment list
Step 4: Cleanup ‚Äì confirm no mock data remains
Sub-steps:
1.	Search TemporaryDatabase references (should be none)
2.	Remove any leftover mock arrays used by pages/components
Step 5: UX polish ‚Äì loading/error states
Sub-steps:
1.	Confirm each page has loading/error/empty state
2.	(Optional) add reusable Spinner and ErrorBanner
Step 6: Frontend env setup (prep for deploy later)
Sub-steps:
1.	Add .env.example
2.	Make API base URL use VITE_API_BASE_URL (not hardcoded localhost)
Step 7: Code cleanup
Sub-steps:
1.	Remove debug logs
2.	Add short comments to tricky parts
________________________________________
DAY 6.5 (NEW): Mobile/Citizen Backend Readiness (Supabase Auth + Django APIs) (THIS IS CANCELLED AND OPTIONAL NOW)
Goal: Citizens authenticate with Supabase Auth (email verification), then use Django APIs for profile, reports, media, and chat.
Step 0: Create a mobile views layer folder (as you requested)
Sub-steps:
1.	Add new backend file: Backend/core/views/mobile.py
2.	Keep citizen/mobile endpoints there (so it‚Äôs organized and separate from police/admin views)
Step 1: Supabase Auth setup (citizen signup/login/verification)
Sub-steps:
1.	In Supabase dashboard:
‚Ä¢	Enable Email Auth
‚Ä¢	Enable Email confirmation (verification email link)
2.	Mobile app:
‚Ä¢	uses Supabase client to signUp(email, password)
‚Ä¢	user clicks verification link in email
‚Ä¢	uses Supabase signInWithPassword(...)
‚Ä¢	mobile app gets a Supabase JWT access token (session token)
Description: Supabase handles verification email; Django does not send OTP/emails.
Step 2: Django ‚Äì Verify Supabase token on mobile API requests
Sub-steps:
1.	Create a helper like validate_supabase_user(request) (reads Authorization: Bearer <supabase_token>)
2.	Verify the Supabase JWT and extract the citizen‚Äôs auth_user_id
3.	Use that identity to allow/deny access
Step 3: Citizen Profile endpoints (stores details in tbl_users)
Sub-steps:
1.	GET /api/v1/mobile/profile/ ‚Üí returns citizen profile from tbl_users
2.	POST /api/v1/mobile/profile/ensure/:
‚Ä¢	first time after signup/login, create the tbl_users row if missing
3.	PATCH /api/v1/mobile/profile/ ‚Üí update profile fields (name, phone, address, emergency contact)
4.	Change password
‚Ä¢	If using Supabase Auth: password change is done via Supabase (not Django)
‚Ä¢	Django should only update profile fields, not passwords
Important: Optional fields (like some details) may be NULL ‚Äî backend should allow nulls.
Step 4: Citizen reports (SOS + detailed report; description/media optional)
Sub-steps:
1.	POST /api/v1/mobile/reports/:
‚Ä¢	required: lat/lng, category (default Emergency for SOS), reporter identity from token
‚Ä¢	optional: description (can be null)
2.	Enforce ‚ÄúActive Case Mode‚Äù rule:
‚Ä¢	if citizen already has a report not Resolved/Canceled ‚Üí block creating a new one (return a friendly error)
Step 5: Citizen media upload (optional media)
Sub-steps:
1.	If user attaches image/video:
‚Ä¢	call Django POST /api/v1/media/ with multipart form data
‚Ä¢	Django uploads to Supabase Storage and creates tbl_media row
2.	If no media, report still submits fine
Step 6: Citizen chat (user ‚Üî police)
Sub-steps:
1.	Update backend to allow sender_type='user' in messages (currently it only allows police)
2.	Add mobile endpoints:
‚Ä¢	GET /api/v1/mobile/reports/{id}/messages/
‚Ä¢	POST /api/v1/mobile/reports/{id}/messages/
3.	Permission checks:
‚Ä¢	citizen can only read/send messages for their own report
Step 7: Citizen cancel report
Sub-steps:
1.	POST /api/v1/mobile/reports/{id}/cancel/ (or PATCH status to Canceled)
2.	Only the report owner can cancel
________________________________________
DAY 7: Testing, Bug Fixing & Documentation 
Goal: Ensure everything works end-to-end and document the system
Step 1: End-to-End Testing Scenarios
Sub-steps:
1.	Scenario 1: Login ‚Üí View dashboard ‚Üí Update report status ‚Üí Logout
2.	Scenario 2: Login ‚Üí Open map ‚Üí Add checkpoint ‚Üí Verify appears on map
3.	Scenario 3: Login ‚Üí Open chat ‚Üí Send message ‚Üí Verify in DB
4.	Scenario 4: Login ‚Üí Analytics ‚Üí Apply filters ‚Üí Export PDF ‚Üí Verify download
5.	Scenario 5: Login ‚Üí Resolved cases ‚Üí View details ‚Üí Export case PDF
Description: Test all major user flows work correctly.
Step 2: Edge Case Testing
Sub-steps:
1.	Test with no data (empty database) - does UI show "No results"?
2.	Test with invalid token (expired) - does app redirect to login?
3.	Test API failures (stop backend) - does UI show error message?
4.	Test long strings (names, descriptions) - does UI break?
5.	Test file upload with large file - does it handle gracefully?
Description: Robust apps handle edge cases without crashing.
Step 3: Bug Tracking & Fixes
Sub-steps:
1.	Create a simple bug list (text file or issue tracker)
2.	Prioritize: Critical (blocks features) ‚Üí Minor (cosmetic)
3.	Fix critical bugs first
4.	Test fix ‚Üí mark as resolved
Description: Systematic bug fixing prevents missing issues.
Step 4: Performance Optimization
Sub-steps:
1.	Check dashboard load time - should be < 2 seconds
2.	Optimize polling intervals (don't spam backend)
3.	Add pagination if report lists are huge (optional)
4.	Lazy load map markers if 100+ pins (optional)
Description: Fast app = better user experience.
Step 5: Documentation - Update README Files
Sub-steps:
1.	Backend README: Installation steps, env vars, run commands, API docs link
2.	Frontend README: Installation steps, env vars, run commands, project structure
3.	Overall README (root): Project overview, architecture diagram (simple text or image)
Description: Future you (or teammates) will thank you.
Step 6: Deployment Preparation Checklist
Sub-steps:
1.	Backend: Dockerfile ready, dependencies listed, env template
2.	Frontend: Build command works (npm run build), env vars documented
3.	Test production build locally before deploying
4.	Document deployment steps (Render/Fly backend, Netlify frontend)
Description: Deployment shouldn't be a mystery.


